Index: include/eve-server/chat/LSCChannel.h
===================================================================
--- include/eve-server/chat/LSCChannel.h	(revision 1000)
+++ include/eve-server/chat/LSCChannel.h	(working copy)
@@ -121,6 +121,37 @@
 
 	const char *GetTypeString();
 
+	uint32 GetChannelID() { return m_channelID; }
+	uint32 GetOwnerID() { return m_ownerID; }
+	Type GetType() { return m_type; }
+	std::string GetDisplayName() { return m_displayName; }
+	std::string GetMOTD() { return m_motd; }
+	std::string GetComparisonKey() { return m_comparisonKey; }
+	bool GetMemberless() { return m_memberless; }
+	std::string GetPassword() { return m_password; }
+	bool GetMailingList() { return m_mailingList; }
+	uint32 GetCSPA() { return m_cspa; }
+	uint32 GetTemporary() { return m_temporary; }
+	uint32 GetMode() { return m_mode; }
+    uint32 GetMemberCount() { return m_chars.size(); }
+
+	void SetOwnerID(uint32 ownerID) { m_ownerID = ownerID; }
+	void SetType(Type new_type) { m_type = new_type; }
+	void SetDisplayName(std::string displayName) { m_displayName = displayName; }
+	void SetMOTD(std::string motd) { m_motd = motd; }
+	void SetComparisonKey(std::string comparisonKey) { m_comparisonKey = comparisonKey; }
+	void SetMemberless(bool memberless) { m_memberless = memberless; }
+	void SetPassword(std::string password) { m_password = password; }
+	void SetMailingList(bool mailingList) { m_mailingList = mailingList; }
+	void SetCSPA(uint32 cspa) { m_cspa = cspa; }
+	void SetTemporary(uint32 temporary) { m_temporary = temporary; }
+	void SetMode(uint32 mode) { m_mode = mode; }
+
+	void GetChannelInfo(uint32 * channelID, uint32 * ownerID, std::string &displayName, std::string &motd, std::string &comparisonKey,
+		bool * memberless, std::string &password, bool * mailingList, uint32 * cspa, uint32 * temporary, uint32 * mode);
+	void SetChannelInfo(uint32 ownerID, std::string displayName, std::string motd, std::string comparisonKey,
+		bool memberless, std::string password, bool mailingList, uint32 cspa, uint32 temporary, uint32 mode);
+
 	bool JoinChannel(Client * c);
 	void LeaveChannel(Client *c, bool self = true);
 	void LeaveChannel(uint32 charID, OnLSC_SenderInfo * si);
Index: include/eve-server/chat/LSCDB.h
===================================================================
--- include/eve-server/chat/LSCDB.h	(revision 1000)
+++ include/eve-server/chat/LSCDB.h	(working copy)
@@ -20,7 +20,7 @@
 	Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 	http://www.gnu.org/copyleft/lesser.txt.
 	------------------------------------------------------------------------------------
-	Author:		Zhur
+	Author:		Zhur, Aknor Jaden
 */
 
 
@@ -52,12 +52,37 @@
 	bool DeleteMessage(uint32 messageID, uint32 readerID);
 	void GetChannelNames(uint32 charID, std::vector<std::string> & names);
 
+	uint32 GetNextAvailableChannelID();
+	bool IsChannelNameAvailable(std::string name);
+	bool IsChannelIDAvailable(uint32 channel_ID);
+	bool IsChannelSubscribedByThisChar(uint32 char_ID, uint32 channel_ID);
+
 	std::string GetRegionName(uint32 id) { return GetChannelName(id, "mapRegions", "regionName", "regionID"); }
 	std::string GetConstellationName(uint32 id) { return GetChannelName(id, "mapConstellations", "constellationName", "constellationID"); }
 	std::string GetSolarSystemName(uint32 id) { return GetChannelName(id, "mapSolarSystems", "solarSystemName", "solarSystemID"); }
 	std::string GetCorporationName(uint32 id) { return GetChannelName(id, "corporation", "corporationName", "corporationID"); }
 	std::string GetCharacterName(uint32 id) { return GetChannelName(id, "entity", "itemName", "itemID"); }
 
+	void GetChannelInformation(std::string & name, uint32 & id,
+		std::string & motd, uint32 & ownerid, std::string & compkey,
+		bool & memberless, std::string & password, bool & maillist,
+		uint32 & cspa, uint32 & temp, uint32 & mode);
+
+	void GetChannelSubscriptions(uint32 charID, std::vector<unsigned long> & ids, std::vector<std::string> & names,
+		std::vector<std::string> & MOTDs, std::vector<unsigned long> & ownerids, std::vector<std::string> & compkeys,
+		std::vector<int> & memberless, std::vector<std::string> & passwords, std::vector<int> & maillists,
+		std::vector<int> & cspas, std::vector<int> & temps, std::vector<int> & modes, int & channelCount);
+
+	std::string GetChannelInfo(uint32 channelID, std::string & name, std::string & motd);
+
+	int WriteNewChannelSubscriptionToDatabase(uint32 characterID, uint32 channelID);
+	int WriteNewChannelToDatabase(uint32 channelID, std::string name, uint32 ownerID, uint32 temporary);
+
+    int UpdateChannelConfigureInfo(LSCChannel * channel);
+
+    int RemoveChannelSubscriptionFromDatabase(uint32 channelID, uint32 charID);
+    int RemoveChannelFromDatabase(uint32 channelID);
+
 protected:
 	std::string GetChannelName(uint32 id, const char * table, const char * column, const char * key);
 };
Index: include/eve-server/chat/LSCService.h
===================================================================
--- include/eve-server/chat/LSCService.h	(revision 1000)
+++ include/eve-server/chat/LSCService.h	(working copy)
@@ -20,7 +20,7 @@
     Place - Suite 330, Boston, MA 02111-1307, USA, or go to
     http://www.gnu.org/copyleft/lesser.txt.
     ------------------------------------------------------------------------------------
-    Author:     Zhur
+    Author:     Zhur, Aknor Jaden
 */
 
 
@@ -58,6 +58,12 @@
  *
 */
 
+// Set the base (minimum) and maximum numbers for any user-created chat channel.
+// All user-created chat channels are created with IDs that are in this set:
+//     [baseChannelID,maxChannelID]  (note the inclusivity in that set)
+#define baseChannelID						200000000
+#define maxChannelID						4294967295
+
 class CommandDispatcher;
 
 class LSCService : public PyService
@@ -93,10 +99,13 @@
     PyCallable_DECL_CALL(LeaveChannels)
     PyCallable_DECL_CALL(LeaveChannel)
     PyCallable_DECL_CALL(CreateChannel)
+	PyCallable_DECL_CALL(Configure)
     PyCallable_DECL_CALL(DestroyChannel)
     PyCallable_DECL_CALL(GetMembers)
     PyCallable_DECL_CALL(GetMember)
     PyCallable_DECL_CALL(SendMessage)
+	PyCallable_DECL_CALL(Invite)
+    PyCallable_DECL_CALL(AccessControl)
 
     PyCallable_DECL_CALL(GetMyMessages)
     PyCallable_DECL_CALL(GetMessageDetails)
@@ -105,8 +114,8 @@
     PyCallable_DECL_CALL(DeleteMessages)
 
 private:
-    uint32 nextFreeChannelID;
-
+    LSCChannel *CreateChannel(uint32 channelID, const char * name, const char * motd, LSCChannel::Type type, const char * compkey,
+		uint32 ownerID, bool memberless, const char * password, bool maillist, uint32 cspa, uint32 temporary, uint32 mode);
     LSCChannel *CreateChannel(uint32 channelID, const char * name, const char * motd, LSCChannel::Type type, bool maillist = false);
     LSCChannel *CreateChannel(uint32 channelID, const char * name, LSCChannel::Type type, bool maillist = false);
     LSCChannel *CreateChannel(uint32 channelID, LSCChannel::Type type);
Index: src/eve-server/chat/LookupService.cpp
===================================================================
--- src/eve-server/chat/LookupService.cpp	(revision 1000)
+++ src/eve-server/chat/LookupService.cpp	(working copy)
@@ -20,7 +20,7 @@
 	Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 	http://www.gnu.org/copyleft/lesser.txt.
 	------------------------------------------------------------------------------------
-	Author:		Zhur
+	Author:		Zhur, Aknor Jaden
 */
 
 
@@ -109,6 +109,7 @@
 	
 	return m_db.LookupChars(args.searchString.c_str(), args.searchOption ? true : false);
 }
+
 //LookupOwners
 PyResult LookupService::Handle_LookupOwners(PyCallArgs &call) {
 	Call_LookupStringInt args;
@@ -116,8 +117,8 @@
 		codelog(SERVICE__ERROR, "Wrong incoming param in LookupOwners");
 		return false;
 	}
-	
-	return m_db.LookupOwners(args.searchString.c_str(),  true );
+
+	return m_db.LookupOwners(args.searchString.c_str(),  args.searchOption ? true : false );
 }
 
 PyResult LookupService::Handle_LookupPlayerCharacters(PyCallArgs &call) {
@@ -127,7 +128,7 @@
 		return false;
 	}
 
-	return m_db.LookupPlayerChars(args.searchString.c_str(),  true);
+	return m_db.LookupPlayerChars(args.searchString.c_str(),  false);
 }
 PyResult LookupService::Handle_LookupCorporations(PyCallArgs &call) {
 	Call_LookupStringInt args;
Index: src/eve-server/chat/LSCChannel.cpp
===================================================================
--- src/eve-server/chat/LSCChannel.cpp	(revision 1000)
+++ src/eve-server/chat/LSCChannel.cpp	(working copy)
@@ -97,6 +97,37 @@
 	_log(LSC__CHANNELS, "Destroying channel \"%s\"", m_displayName.c_str());
 }
 
+void LSCChannel::GetChannelInfo(uint32 * channelID, uint32 * ownerID, std::string &displayName, std::string &motd, std::string &comparisonKey,
+	bool * memberless, std::string &password, bool * mailingList, uint32 * cspa, uint32 * temporary, uint32 * mode)
+{
+	*channelID = GetChannelID();
+	*ownerID = GetOwnerID();
+	displayName = GetDisplayName();
+	motd = GetMOTD();
+	comparisonKey = GetComparisonKey();
+	*memberless = GetMemberless();
+	password = GetPassword();
+	*mailingList = GetMailingList();
+	*cspa = GetCSPA();
+	*temporary = GetTemporary();
+	*mode = GetMode();
+}
+
+void LSCChannel::SetChannelInfo(uint32 ownerID, std::string displayName, std::string motd, std::string comparisonKey,
+	bool memberless, std::string password, bool mailingList, uint32 cspa, uint32 temporary, uint32 mode)
+{
+	SetOwnerID(ownerID);
+	SetDisplayName(displayName);
+	SetMOTD(motd);
+	SetComparisonKey(comparisonKey);
+    SetMemberless(memberless);
+	SetPassword(password);
+	SetMailingList(mailingList);
+	SetCSPA(cspa);
+	SetTemporary(temporary);
+	SetMode(mode);
+}
+
 bool LSCChannel::JoinChannel(Client * c) {
 	_log(LSC__CHANNELS, "Channel %s: Join from %s", m_displayName.c_str(), c->GetName());
 
@@ -128,6 +159,7 @@
 
 	return true;
 }
+
 void LSCChannel::LeaveChannel(uint32 charID, OnLSC_SenderInfo * si) {
 	_log(LSC__CHANNELS, "Channel %s: Leave from %u", m_displayName.c_str(), charID);
 
@@ -152,6 +184,7 @@
 	PyTuple *answer = leave.Encode();
 	m_service->entityList().Multicast("OnLSC", GetTypeString(), &answer, mct);
 }
+
 void LSCChannel::LeaveChannel(Client *c, bool self) {
 	_log(LSC__CHANNELS, "Channel %s: Leave from %s", m_displayName.c_str(), c->GetName());
 
@@ -179,6 +212,7 @@
 	m_chars.erase(charID);
 	c->ChannelLeft(this);
 }
+
 void LSCChannel::Evacuate(Client * c) {
 	OnLSC_DestroyChannel dc;
 
@@ -197,6 +231,7 @@
 	PyTuple *answer = dc.Encode();
 	m_service->entityList().Multicast("OnLSC", GetTypeString(), &answer, mct);
 }
+
 void LSCChannel::SendMessage(Client * c, const char * message, bool self) {
 	MulticastTarget mct;
 
@@ -229,17 +264,6 @@
 	m_service->entityList().Multicast("OnLSC", GetTypeString(), &answer, mct);
 }
 
-	
-
-		
-	
-		
-	
-
-
-
-
-
 bool LSCChannel::IsJoined(uint32 charID) {
 	return m_chars.find(charID) != m_chars.end();
 }
@@ -289,6 +313,7 @@
 
 	return line.Encode();
 }
+
 PyRep *LSCChannel::EncodeID() {
 	if (m_type == normal)
 		return (new PyInt(m_channelID));
@@ -317,6 +342,7 @@
 	
 	return info.Encode();
 }
+
 PyRep *LSCChannel::EncodeChannelMods()
 {
 	ChannelJoinChannelMods info;
@@ -327,6 +353,7 @@
 
 	return info.Encode();
 }
+
 PyRep *LSCChannel::EncodeChannelChars() {
 	ChannelJoinChannelChars info;
     info.lines = new PyList;
@@ -343,6 +370,7 @@
 
 	return info.Encode();
 }
+
 PyRep *LSCChannel::EncodeEmptyChannelChars() {
 	ChannelJoinChannelChars info;
     info.lines = new PyList;
@@ -365,16 +393,3 @@
 	}
 	return("unknown");
 }
-
-
-
-
-
-
-
-
-
-
-
-
-
Index: src/eve-server/chat/LSCDB.cpp
===================================================================
--- src/eve-server/chat/LSCDB.cpp	(revision 1000)
+++ src/eve-server/chat/LSCDB.cpp	(working copy)
@@ -20,14 +20,14 @@
 	Place - Suite 330, Boston, MA 02111-1307, USA, or go to
 	http://www.gnu.org/copyleft/lesser.txt.
 	------------------------------------------------------------------------------------
-	Author:		Zhur
+	Author:		Zhur, Aknor Jaden
 */
 
 
-
 #include "EVEServerPCH.h"
 #include <ctype.h>
 
+
 PyObject *LSCDB::LookupChars(const char *match, bool exact) {
 	DBQueryResult res;
 	
@@ -62,20 +62,37 @@
 	return DBResultToRowset(res);
 }
 
+
 PyObject *LSCDB::LookupOwners(const char *match, bool exact) {
 	DBQueryResult res;
 	
 	std::string matchEsc;
 	sDatabase.DoEscapeString(matchEsc, match);
-	
+
+    // so each row needs "ownerID", "ownerName", and "groupID"
+    // ownerID = either characterID or corporationID
+    // ownerName = either characterName or corporationName
+    // groupID = either 1 for character or 2 for corporation
+
 	if(!sDatabase.RunQuery(res,
-		"SELECT"
-		" characterID AS ownerID, itemName AS characterName, typeID" //characterID AS ownerID - client wants characterID to be called ownerID
-		" FROM character_"
-		"  LEFT JOIN entity ON characterID = itemID"
-		" WHERE characterID >= 140000000 AND online = 1" //AND online = 1 - checks if the target character is online, avoiding an epic fail
-		"  AND itemName %s '%s'",
-		exact?"=":"RLIKE", matchEsc.c_str()))
+        "SELECT"
+        "  character_.characterID AS ownerID,"
+        "  entity.itemName AS ownerName,"
+        "  invTypes.groupID AS groupID"
+        " FROM character_"
+        "  LEFT JOIN entity ON characterID = itemID"
+        "  LEFT JOIN invTypes ON entity.typeID = invTypes.typeID"
+        " WHERE character_.characterID >= 140000000"
+        "  AND entity.itemName %s '%s'"
+        " UNION "
+        "SELECT"
+        "  corporation.corporationID AS ownerID,"
+        "  corporation.corporationName AS ownerName,"
+        "  invTypes.groupID AS groupID"
+        " FROM corporation"
+        "  LEFT JOIN invTypes ON groupID = 2"
+        " WHERE corporation.corporationName %s '%s'",
+		(exact?"=":"RLIKE"), matchEsc.c_str(), (exact?"=":"RLIKE"), matchEsc.c_str()))
 	{
 		_log(DATABASE__ERROR, "Failed to lookup player char '%s': %s.", matchEsc.c_str(), res.error.c_str());
 		return NULL;
@@ -84,6 +101,7 @@
 	return DBResultToRowset(res);
 }
 
+
 PyObject *LSCDB::LookupPlayerChars(const char *match, bool exact) {
 	DBQueryResult res;
 
@@ -105,6 +123,102 @@
 	return DBResultToRowset(res);
 }
 
+
+PyObject *LSCDB::LookupCorporations(const std::string & search) {
+	DBQueryResult res;
+	std::string secure;
+	sDatabase.DoEscapeString(secure, search);
+
+	if (!sDatabase.RunQuery(res, 
+		" SELECT "
+		" corporationID, corporationName, corporationType "
+		" FROM corporation "
+		" WHERE corporationName RLIKE '%s'", secure.c_str()))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
+		return 0;
+	}
+
+	return DBResultToRowset(res);
+}
+
+
+PyObject *LSCDB::LookupFactions(const std::string & search) {
+	DBQueryResult res;
+	std::string secure;
+	sDatabase.DoEscapeString(secure, search);
+
+	if (!sDatabase.RunQuery(res, 
+		" SELECT "
+		" factionID, factionName "
+		" FROM chrFactions "
+		" WHERE factionName RLIKE '%s'", secure.c_str()))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
+		return 0;
+	}
+
+	return DBResultToRowset(res);
+}
+
+
+PyObject *LSCDB::LookupCorporationTickers(const std::string & search) {
+	DBQueryResult res;
+	std::string secure;
+	sDatabase.DoEscapeString(secure, search);
+
+	if (!sDatabase.RunQuery(res, 
+		" SELECT "
+		" corporationID, corporationName, tickerName "
+		" FROM corporation "
+		" WHERE tickerName RLIKE '%s'", secure.c_str()))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
+		return 0;
+	}
+
+	return DBResultToRowset(res);
+}
+
+
+PyObject *LSCDB::LookupStations(const std::string & search) {
+	DBQueryResult res;
+	std::string secure;
+	sDatabase.DoEscapeString(secure, search);
+
+	if (!sDatabase.RunQuery(res, 
+		" SELECT "
+		" stationID, stationName, stationTypeID "
+		" FROM staStations "
+		" WHERE stationName RLIKE '%s'", secure.c_str()))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
+		return 0;
+	}
+
+	return DBResultToRowset(res);
+}
+
+
+PyObject *LSCDB::LookupKnownLocationsByGroup(const std::string & search, uint32 typeID) {
+	DBQueryResult res;
+	std::string secure;
+	sDatabase.DoEscapeString(secure, search);
+
+	if (!sDatabase.RunQuery(res, 
+		" SELECT "
+		" itemID, itemName, typeID "
+		" FROM entity "
+		" WHERE itemName RLIKE '%s' AND typeID = %u", secure.c_str(), typeID))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
+		return 0;
+	}
+
+	return DBResultToRowset(res);
+}
+
+
 //temporarily relocated into ServiceDB until some things get cleaned up...
 uint32 LSCDB::StoreMail(uint32 senderID, uint32 recipID, const char * subject, const char * message, uint64 sentTime) {
 	DBQueryResult res;
@@ -153,6 +267,7 @@
 	return (messageID);
 }
 
+
 PyObject *LSCDB::GetMailHeaders(uint32 recID) {
 	DBQueryResult res;
 
@@ -168,6 +283,7 @@
 	return DBResultToRowset(res);
 }
 
+
 PyRep *LSCDB::GetMailDetails(uint32 messageID, uint32 readerID) {
 	DBQueryResult result;
 	DBResultRow row;
@@ -213,6 +329,7 @@
 	return(details.Encode());
 }
 
+
 bool LSCDB::MarkMessageRead(uint32 messageID) {
 	DBerror err;
 
@@ -229,6 +346,7 @@
 	return true;
 }
 
+
 bool LSCDB::DeleteMessage(uint32 messageID, uint32 readerID) {
 	DBerror err;
 	bool ret = true;
@@ -253,109 +371,194 @@
 	return ret;
 
 }
-PyObject *LSCDB::LookupCorporations(const std::string & search) {
+
+
+void LSCDB::GetChannelNames(uint32 charID, std::vector<std::string> & names) {
 	DBQueryResult res;
-	std::string secure;
-	sDatabase.DoEscapeString(secure, search);
 
 	if (!sDatabase.RunQuery(res, 
 		" SELECT "
-		" corporationID, corporationName, corporationType "
-		" FROM corporation "
-		" WHERE corporationName RLIKE '%s'", secure.c_str()))
+		"	entity.itemName AS characterName, "
+		"	corporation.corporationName, "
+		"	mapSolarSystems.solarSystemName, "
+		"	mapConstellations.constellationName, "
+		"	mapRegions.regionName "
+		" FROM character_ "
+		"	LEFT JOIN entity ON character_.characterID = entity.itemID "
+		"	LEFT JOIN corporation ON character_.corporationID = corporation.corporationID "
+		"	LEFT JOIN mapSolarSystems ON character_.solarSystemID = mapSolarSystems.solarSystemID "
+		"	LEFT JOIN mapConstellations ON character_.constellationID = mapConstellations.constellationID "
+		"	LEFT JOIN mapRegions ON character_.regionID = mapRegions.regionID "
+		" WHERE character_.characterID = %u ", charID))
 	{
 		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
-		return 0;
+		return;
 	}
 
-	return DBResultToRowset(res);
+	DBResultRow row;
+
+	if (!res.GetRow(row)) {
+		_log(SERVICE__ERROR, "CharID %u isn't present in the database", charID);
+		return;
+	}
+
+	names.push_back(row.GetText(0));	// charName
+	names.push_back(row.GetText(1));	// corpName
+	names.push_back(row.GetText(2));	// solsysName
+	names.push_back(row.GetText(3));	// constName
+	names.push_back(row.GetText(4));	// regionName
 }
-PyObject *LSCDB::LookupFactions(const std::string & search) {
+
+
+// Function: Query 'channels' table for a list of all channelIDs and traverse that list from the beginning to find
+// the first gap in consecutive channelIDs and return the value for the first number in that gap.
+uint32 LSCDB::GetNextAvailableChannelID()
+{
 	DBQueryResult res;
-	std::string secure;
-	sDatabase.DoEscapeString(secure, search);
 
+    // Query the 'channels' table to get a list of all channel IDs.
+    // NOTE: For large servers, this is inefficient and as everything in this file should be using
+    // the cached object system rather than touching the database, this query could cause large server slow-down
+    // if there is a very large number of existing channels in the database.
 	if (!sDatabase.RunQuery(res, 
 		" SELECT "
-		" factionID, factionName "
-		" FROM chrFactions "
-		" WHERE factionName RLIKE '%s'", secure.c_str()))
+		"	channelID "
+		" FROM channels "
+		" WHERE channelID >= %u ", baseChannelID))
 	{
 		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
 		return 0;
 	}
 
-	return DBResultToRowset(res);
+	DBResultRow row;
+	int rowCount = 0;
+	int32 currentChannelID = baseChannelID;
+	int32 nextChannelID = baseChannelID;
+
+	// Traverse through the rows in the query result until the first gap is found
+	// and return the value that would be first (or only one) in the gap as the next
+	// free channel ID:
+	while(res.GetRow(row))
+	{
+		nextChannelID = row.GetUInt(0);
+		if (nextChannelID > (currentChannelID + 1))
+			return (currentChannelID + 1);
+		else
+			currentChannelID = nextChannelID;
+	}
+
+    // Check to make sure that the next available channelID is not equal to the Maximum channel ID value
+	if (nextChannelID < maxChannelID)
+		return (++nextChannelID);
+	else
+		return 0;	// No free channel IDs found (this should never happen as there are way too many IDs to exhaust)
 }
-PyObject *LSCDB::LookupCorporationTickers(const std::string & search) {
+
+
+// Function: Return true or false result for the check of whether or not the specified
+// channel 'displayName' is already being used by a channel.
+bool LSCDB::IsChannelNameAvailable(std::string name)
+{
 	DBQueryResult res;
-	std::string secure;
-	sDatabase.DoEscapeString(secure, search);
 
+	// MySQL query channels table for any channel whose displayName matches "name":
 	if (!sDatabase.RunQuery(res, 
 		" SELECT "
-		" corporationID, corporationName, tickerName "
-		" FROM corporation "
-		" WHERE tickerName RLIKE '%s'", secure.c_str()))
+		"	displayName "
+		" FROM channels "
+		" WHERE displayName = upper('%s')", name.c_str()))
 	{
 		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
-		return 0;
+		return false;
 	}
 
-	return DBResultToRowset(res);
+	DBResultRow row;
+
+    // Return true (this 'displayName' not in use) if there are no rows returned by the query:
+	if (!res.GetRow(row))
+		return true;
+	else
+		return false;
 }
-PyObject *LSCDB::LookupStations(const std::string & search) {
+
+
+// Function: Return true or false result for the check of whether or not the specified
+// channelID is available to be taken for a new channel's channelID.
+bool LSCDB::IsChannelIDAvailable(uint32 channelID)
+{
 	DBQueryResult res;
-	std::string secure;
-	sDatabase.DoEscapeString(secure, search);
 
 	if (!sDatabase.RunQuery(res, 
 		" SELECT "
-		" stationID, stationName, stationTypeID "
-		" FROM staStations "
-		" WHERE stationName RLIKE '%s'", secure.c_str()))
+		"	channelID "
+		" FROM channels "
+		" WHERE channelID = %u", channelID ))
 	{
 		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
-		return 0;
+		return false;
 	}
 
-	return DBResultToRowset(res);
+	DBResultRow row;
+
+    // Return true (this channelID not in use) if there are no rows returned by the query:
+	if (!(res.GetRow(row)))
+		return true;
+	else
+		return false;
 }
-PyObject *LSCDB::LookupKnownLocationsByGroup(const std::string & search, uint32 typeID) {
+
+
+// Function: Return true or false result for the check of whether or not the channel
+// specified by channelID is already subscribed to by the character specified by charID.
+bool LSCDB::IsChannelSubscribedByThisChar(uint32 charID, uint32 channelID)
+{
 	DBQueryResult res;
-	std::string secure;
-	sDatabase.DoEscapeString(secure, search);
 
 	if (!sDatabase.RunQuery(res, 
 		" SELECT "
-		" itemID, itemName, typeID "
-		" FROM entity "
-		" WHERE itemName RLIKE '%s' AND typeID = %u", secure.c_str(), typeID))
+		"	channelID, "
+		"   charID "
+		" FROM channelChars "
+		" WHERE channelID = %u AND charID = %u", channelID, charID ))
 	{
 		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
-		return 0;
+		return false;
 	}
 
-	return DBResultToRowset(res);
+	DBResultRow row;
+
+    // Return false (no subscription exists) if there are no rows returned by the query:
+	if (!(res.GetRow(row)))
+		return false;
+	else
+		return true;
 }
 
-void LSCDB::GetChannelNames(uint32 charID, std::vector<std::string> & names) {
+
+// Function: Query 'channels' table for the channel whose 'displayName' matches the name specified,
+// then return all parameters for that channel.
+void LSCDB::GetChannelInformation(std::string & name, uint32 & id,
+		std::string & motd, uint32 & ownerid, std::string & compkey,
+		bool & memberless, std::string & password, bool & maillist,
+		uint32 & cspa, uint32 & temp, uint32 & mode)
+{
 	DBQueryResult res;
 
 	if (!sDatabase.RunQuery(res, 
 		" SELECT "
-		"	entity.itemName AS characterName, "
-		"	corporation.corporationName, "
-		"	mapSolarSystems.solarSystemName, "
-		"	mapConstellations.constellationName, "
-		"	mapRegions.regionName "
-		" FROM character_ "
-		"	LEFT JOIN entity ON character_.characterID = entity.itemID "
-		"	LEFT JOIN corporation ON character_.corporationID = corporation.corporationID "
-		"	LEFT JOIN mapSolarSystems ON character_.solarSystemID = mapSolarSystems.solarSystemID "
-		"	LEFT JOIN mapConstellations ON character_.constellationID = mapConstellations.constellationID "
-		"	LEFT JOIN mapRegions ON character_.regionID = mapRegions.regionID "
-		" WHERE character_.characterID = %u ", charID))
+		"	channelID, "
+		"	displayName, "
+		"   motd, "
+		"   ownerID, "
+		"   comparisonKey, "
+		"   memberless, "
+		"   password, "
+		"   mailingList, "
+		"   cspa, "
+		"   temporary, "
+		"   mode "
+		" FROM channels "
+		" WHERE displayName = upper('%s')", name.c_str()))
 	{
 		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
 		return;
@@ -363,18 +566,124 @@
 
 	DBResultRow row;
 
-	if (!res.GetRow(row)) {
+	if (!(res.GetRow(row)))
+	{
+		_log(SERVICE__ERROR, "Channel named '%s' isn't present in the database", name);
+		return;
+	}
+
+	id = row.GetUInt(0);
+	name = row.GetText(1);
+	motd = row.GetText(2);
+	ownerid = row.GetUInt(3);
+	compkey = row.GetText(4);
+	memberless = row.GetUInt(5) ? true : false;
+	password = (row.GetText(6) == NULL ? "" : row.GetText(6));	// empty password field in channels table row returns NULL, so fill this string with "" in that case
+	maillist = row.GetUInt(7) ? true : false;
+	cspa = row.GetUInt(8);
+	temp = row.GetUInt(9);
+	mode = row.GetUInt(10);
+}
+
+
+// Function: Query the 'channelChars' table for all channels subscribed to by the character specified by charID and
+// return lists of parameters for all of those channels as well as a total channel count.
+void LSCDB::GetChannelSubscriptions(uint32 charID, std::vector<unsigned long> & ids, std::vector<std::string> & names,
+		std::vector<std::string> & MOTDs, std::vector<unsigned long> & ownerids, std::vector<std::string> & compkeys,
+		std::vector<int> & memberless, std::vector<std::string> & passwords, std::vector<int> & maillists,
+		std::vector<int> & cspas, std::vector<int> & temps, std::vector<int> & modes, int & channelCount)
+{
+	DBQueryResult res;
+
+	// Cross-reference "channelchars" table with "channels" table using the charID
+	// The result is a two column multi-row structure where each row is a channel
+	// that the character (charID) is subscribed to where the channel ID is presented
+	// in the first column and the display name of that channel in the second column
+	if (!sDatabase.RunQuery(res, 
+		" SELECT "
+		"	channelID, "
+		"	displayName, "
+		"   motd, "
+		"   ownerID, "
+		"   comparisonKey, "
+		"   memberless, "
+		"   password, "
+		"   mailingList, "
+		"   cspa, "
+		"   temporary, "
+		"   mode "
+		" FROM channels "
+		" WHERE channelID = ANY ("
+		"   SELECT channelID FROM channelChars WHERE charID = %u )", charID))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
+		return;
+	}
+
+	DBResultRow row;
+	int rowCount = 0;
+
+	// Traverse through all rows in the query result and copy the IDs and displayNames to the
+	// "ids" and "names" vectors for return to the calling function:
+	while(res.GetRow(row))
+	{
+		++rowCount;
+
+		ids.push_back(row.GetUInt(0));
+		names.push_back((row.GetText(1) == NULL ? "" : row.GetText(1)));	// empty displayName field in channels table row returns NULL, so fill this string with "" in that case
+		MOTDs.push_back((row.GetText(2) == NULL ? "" : row.GetText(2)));	// empty motd field in channels table row returns NULL, so fill this string with "" in that case
+		ownerids.push_back(row.GetUInt(3));
+		compkeys.push_back((row.GetText(4) == NULL ? "" : row.GetText(4)));	// empty comparisonKey field in channels table row returns NULL, so fill this string with "" in that case
+		memberless.push_back(row.GetUInt(5));
+		passwords.push_back((row.GetText(6) == NULL ? "" : row.GetText(6)));	// empty password field in channels table row returns NULL, so fill this string with "" in that case
+		maillists.push_back(row.GetUInt(7));
+		cspas.push_back(row.GetUInt(8));
+		temps.push_back(row.GetUInt(9));
+		modes.push_back(row.GetUInt(10));
+	}
+
+	if (rowCount == 0) {
 		_log(SERVICE__ERROR, "CharID %u isn't present in the database", charID);
 		return;
 	}
 
-	names.push_back(row.GetText(0));	// charName
-	names.push_back(row.GetText(1));	// corpName
-	names.push_back(row.GetText(2));	// solsysName
-	names.push_back(row.GetText(3));	// constName
-	names.push_back(row.GetText(4));	// regionName
+	channelCount = rowCount;
 }
 
+
+std::string LSCDB::GetChannelInfo(uint32 channelID, std::string & name, std::string & motd)
+{
+	DBQueryResult res;
+
+	if (!sDatabase.RunQuery(res, 
+		" SELECT "
+		"	displayName, "
+		"   motd "
+		" FROM channels "
+		" WHERE channelID = %u ", channelID))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", res.error.c_str());
+		char err[20];
+		snprintf(err, 20, "Unknown %u", channelID);
+		return(err);
+	}
+
+	DBResultRow row;
+
+	if (!res.GetRow(row)) {
+		_log(SERVICE__ERROR, "Couldn't find %u in table channels", channelID);
+		char err[20];
+		snprintf(err, 20, "Unknown %u", channelID);
+		return(err);
+	}
+
+	name = row.GetText(0);
+	motd = row.GetText(1);
+
+	return ("");
+}
+
+
 std::string LSCDB::GetChannelName(uint32 id, const char * table, const char * column, const char * key) {
 	DBQueryResult res;
 
@@ -401,3 +710,142 @@
 
 	return (row.GetText(0));
 }
+
+
+// Take the channelID of a chat channel that a character specified by characterID just subscribed to
+// and create a new entry in the 'channelChars' table for this subscription.
+int LSCDB::WriteNewChannelSubscriptionToDatabase(uint32 characterID, uint32 channelID)
+{
+	DBQueryResult res;
+	DBerror err;
+	DBResultRow row;
+
+	if (!sDatabase.RunQuery(err,
+		" INSERT INTO channelChars "
+		" (channelID, corpID, charID, allianceID, role, extra) VALUES (%u, 0, %u, 0, 0, 0) ",
+		channelID, characterID
+		))
+	{
+		_log(SERVICE__ERROR, "Error in query, Channel Subscription content couldn't be saved: %s", err.c_str());
+		return 0;
+	}
+	else
+		return 1;
+}
+
+
+// Function: Take channelID, channel name, the characterID of the character creating the channel, and a flag
+// indicating whether this channel is a private convo (temporary), then create a new entry in the 'channels'
+// table.
+int LSCDB::WriteNewChannelToDatabase(uint32 channelID, std::string name, uint32 ownerID, uint32 temporary)
+{
+	DBQueryResult res;
+	DBerror err;
+	DBResultRow row;
+
+	if (!sDatabase.RunQuery(err,
+		" INSERT INTO channels "
+		"      (channelID, ownerID, displayName, motd, comparisonKey, memberless, password, mailingList,"
+		"       cspa, temporary, mode, subscribed, estimatedMemberCount) "
+		" VALUES (%u, %u, '%s', '%s', '%s', 0, NULL, 0, 0, %u, 1, 1, 1) ",
+		channelID, ownerID, name.c_str(), "", name.c_str(), temporary
+		))
+	{
+		_log(SERVICE__ERROR, "Error in query, New Channel couldn't be saved: %s", err.c_str());
+		return 0;
+	}
+	else
+		return 1;
+}
+
+
+// Function: Accept pointer to a LSCChannel object for the channel being updated in its
+// existing entry in the 'channels' table.  Take all channel parameters and write them to the
+// selected 'channels' table entry based on channelID
+int LSCDB::UpdateChannelConfigureInfo(LSCChannel * channel)
+{
+	DBerror err;
+    std::string new_password;
+
+    // Ensure that the string "NULL" is written into the table row for the password field if
+    // the channel's password is empty
+    if (channel->GetPassword() == "")
+        new_password = "NULL";
+    else
+        new_password = "'" + channel->GetPassword() + "'";
+
+	if (!sDatabase.RunQuery(err,
+		" UPDATE channels "
+		" SET "
+        " displayName = '%s', "
+        " motd = '%s', "
+        " comparisonKey = '%s', "
+        " memberless = %u, "
+        " password = %s, "
+        " mailingList = %u, "
+        " cspa = %u, "
+        " temporary = %u, "
+        " mode = %u, "
+        " subscribed = %u, "
+        " estimatedMemberCount = %u "
+        " WHERE channelID=%u",
+        channel->GetDisplayName().c_str(),
+        channel->GetMOTD().c_str(),
+        channel->GetComparisonKey().c_str(),
+        ((channel->GetMemberless()) ? 1 : 0),
+        new_password.c_str(),
+        ((channel->GetMailingList()) ? 1 : 0),
+        channel->GetCSPA(),
+        channel->GetTemporary(),
+        channel->GetMode(),
+        1,
+        channel->GetMemberCount(),
+        channel->GetChannelID()
+		))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", err.c_str());
+		return false;
+	}
+
+	return true;
+}
+
+
+// Function: Remove subscription to the chat channel specified by channelID for the character
+// specified by charID from the 'channelChars' table
+int LSCDB::RemoveChannelSubscriptionFromDatabase(uint32 channelID, uint32 charID)
+{
+	DBerror err;
+	bool ret = true;
+
+	if (!sDatabase.RunQuery(err,
+		" DELETE FROM channelChars "
+		" WHERE channelID=%u AND charID=%u", channelID, charID
+		))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", err.c_str());
+		ret = false;
+	}
+
+	return ret;
+}
+
+
+// Function: Remove the chat channel from the 'channels' table using specified channelID
+int LSCDB::RemoveChannelFromDatabase(uint32 channelID)
+{
+	DBerror err;
+	bool ret = true;
+
+	if (!sDatabase.RunQuery(err,
+		" DELETE FROM channels "
+		" WHERE channelID=%u", channelID
+		))
+	{
+		codelog(SERVICE__ERROR, "Error in query: %s", err.c_str());
+		ret = false;
+	}
+
+	return ret;
+}
+
Index: src/eve-server/chat/LSCService.cpp
===================================================================
--- src/eve-server/chat/LSCService.cpp	(revision 1000)
+++ src/eve-server/chat/LSCService.cpp	(working copy)
@@ -20,7 +20,7 @@
     Place - Suite 330, Boston, MA 02111-1307, USA, or go to
     http://www.gnu.org/copyleft/lesser.txt.
     ------------------------------------------------------------------------------------
-    Author:     Zhur
+    Author:     Zhur, Aknor Jaden
 */
 
 
@@ -33,8 +33,7 @@
 LSCService::LSCService(PyServiceMgr *mgr, CommandDispatcher* cd)
 : PyService(mgr, "LSC"),
   m_dispatch(new Dispatcher(this)),
-  m_commandDispatch(cd),
-  nextFreeChannelID(200000000)
+  m_commandDispatch(cd)
 {
     _SetCallDispatcher(m_dispatch);
 
@@ -45,10 +44,13 @@
     PyCallable_REG_CALL(LSCService, LeaveChannels)
     PyCallable_REG_CALL(LSCService, LeaveChannel)
     PyCallable_REG_CALL(LSCService, CreateChannel)
+	PyCallable_REG_CALL(LSCService, Configure)
     PyCallable_REG_CALL(LSCService, DestroyChannel)
 	PyCallable_REG_CALL(LSCService, GetMembers)
     PyCallable_REG_CALL(LSCService, GetMember)
     PyCallable_REG_CALL(LSCService, SendMessage)
+	PyCallable_REG_CALL(LSCService, Invite)
+    PyCallable_REG_CALL(LSCService, AccessControl)
 
     PyCallable_REG_CALL(LSCService, GetMyMessages)
     PyCallable_REG_CALL(LSCService, GetMessageDetails)
@@ -59,6 +61,7 @@
     InitiateStaticChannels();
 }
 
+
 LSCService::~LSCService() {
     delete m_dispatch;
     std::map<uint32, LSCChannel *>::iterator cur, end;
@@ -69,6 +72,92 @@
     }
 }
 
+
+///////////////////////////////////////////////////////////////////////////////
+//
+// Eve Chat calls
+//
+///////////////////////////////////////////////////////////////////////////////
+
+const int cmode = 2950;
+
+
+LSCChannel *LSCService::CreateChannel(uint32 channelID, const char * name, const char * motd, LSCChannel::Type type, const char * compkey,
+	uint32 ownerID, bool memberless, const char * password, bool maillist, uint32 cspa, uint32 temporary, uint32 mode) {
+		return m_channels[channelID] = new LSCChannel(this, channelID, type, ownerID, name, motd, compkey, memberless, password, maillist,
+			cspa, temporary, mode);
+}
+
+
+LSCChannel *LSCService::CreateChannel(uint32 channelID, const char * name, const char * motd, LSCChannel::Type type, bool maillist) {
+	return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name, motd, NULL, false, "", maillist, true, false, cmode);//ownerID must be sent in responce to GetEveOwners
+}
+
+
+LSCChannel *LSCService::CreateChannel(uint32 channelID, const char * name, LSCChannel::Type type, bool maillist) {
+ 	return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name, NULL, NULL, false, "", maillist, true, false, cmode);
+}
+
+
+LSCChannel *LSCService::CreateChannel(uint32 channelID) {
+    LSCChannel::Type type;
+    std::string name;
+    std::string motd;
+    if (IsRegion(channelID)) { type = LSCChannel::region; name = "System Channels\\Region"; motd = m_db.GetRegionName(channelID); }
+    else if (IsConstellation(channelID)) {type = LSCChannel::constellation; name = "System Channels\\Constellation"; motd = m_db.GetConstellationName(channelID); }
+    else if (IsSolarSystem(channelID)) { type = LSCChannel::solarsystem; name = "System Channels\\Local"; motd = m_db.GetSolarSystemName(channelID); }
+    // official corporations
+    else if ((channelID >= 1000000) && (channelID < 2000000)) { type = LSCChannel::corp; name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
+    // player-created corporations
+    else if ((channelID >= 2000000) && (channelID < 3000000)) { type = LSCChannel::corp; name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
+    // Only the Help\Rookie and Help\Help channels have channelIDs < 1000000:
+	else { type = LSCChannel::normal; m_db.GetChannelInfo(channelID, name, motd); }
+
+	return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name.c_str(), motd.c_str(), NULL, false, NULL, false, true, false, cmode);
+}
+
+
+LSCChannel *LSCService::CreateChannel(uint32 channelID, LSCChannel::Type type) {
+    std::string name;
+    std::string motd;
+    if (IsRegion(channelID)) { name = "System Channels\\Region"; motd = m_db.GetRegionName(channelID); }
+    else if (IsConstellation(channelID)) { name = "System Channels\\Constellation"; motd = m_db.GetConstellationName(channelID); }
+    else if (IsSolarSystem(channelID)) { name = "System Channels\\Local"; motd = m_db.GetSolarSystemName(channelID); }
+    // official corporations
+    else if ((channelID >= 1000000) && (channelID < 2000000)) { name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
+    // player-created corporations
+    else if ((channelID >= 2000000) && (channelID < 3000000)) { name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
+    // Only the Help\Rookie and Help\Help channels have channelIDs < 1000000:
+	else { m_db.GetChannelInfo(channelID, name, motd); } //GetCharacterName(channelID); motd = ""; }
+
+    return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name.c_str(), motd.c_str(), NULL, false, NULL, false, true, false, cmode);
+}
+
+
+LSCChannel *LSCService::CreateChannel(const char * name, bool maillist) {
+	uint32 nextFreeChannelID = m_db.GetNextAvailableChannelID();
+
+	if( nextFreeChannelID )
+		return CreateChannel(nextFreeChannelID, name, LSCChannel::normal, maillist);
+	else
+		return NULL;
+}
+
+
+void LSCService::CreateSystemChannel(uint32 systemID) {
+    if (m_channels.find(systemID) == m_channels.end()) {
+        CreateChannel(systemID, "System Channels\\Local", m_db.GetSolarSystemName(systemID).c_str(), LSCChannel::solarsystem);
+    }
+}
+
+
+void LSCService::InitiateStaticChannels() {
+    // maybe, but only maybe, this stuff could be replaced by a nice database call
+    //CreateChannel(1, "Help\\Rookie Help", "Rookie motd", LSCChannel::normal);
+    //CreateChannel(2, "Help\\Help", "Help motd", LSCChannel::normal);
+}
+
+
 PyResult LSCService::Handle_GetChannels(PyCallArgs &call) {
     /*
         Assume this is only called when the char's logging in.
@@ -91,28 +180,89 @@
     */
     std::vector<std::string> names;
 
+	// Call to LSCDB object to get the following strings in this order (index is to left):
+	//	0	Character name
+	//	1	Corporation name
+	//	2	Solar System name
+	//	3	Constellation name
+	//	4	Region name
     m_db.GetChannelNames(call.client->GetCharacterID(), names);
 
     uint32 channelID = call.client->GetCharacterID();
+
+	// Use characterID to join this character's mailing list (channelID == characterID):
     if( m_channels.find(channelID) == m_channels.end() )
         CreateChannel(channelID, call.client->GetName(), LSCChannel::normal, true);
 
+	// Use corporationID to join this character's CORP chat channel:
     channelID = call.client->GetCorporationID();
     if( m_channels.find(channelID) == m_channels.end() )
         CreateChannel(channelID, "System Channels\\Corp", names[1].c_str(), LSCChannel::corp);
 
+	// Use solarSystemID to join the Local chat of this character's present solar system:
     channelID = call.client->GetSystemID();
     if( m_channels.find(channelID) == m_channels.end() )
         CreateChannel(channelID, "System Channels\\Local", names[2].c_str(), LSCChannel::solarsystem);
 
+	// Use constellationID to join the Constellation chat of this character's present constellation:
     channelID = call.client->GetConstellationID();
     if( m_channels.find(channelID) == m_channels.end() )
         CreateChannel(channelID, "System Channels\\Constellation", names[3].c_str(), LSCChannel::constellation);
 
+	// Use regionID to join the Region chat of this character's present region:
     channelID = call.client->GetRegionID();
     if( m_channels.find(channelID) == m_channels.end() )
         CreateChannel(channelID, "System Channels\\Region", names[4].c_str(), LSCChannel::region);
 
+	std::vector<unsigned long> charChannelIDs;
+	std::vector<std::string> charChannelNames;
+	std::vector<std::string> charChannelMOTDs;
+	std::vector<unsigned long> charOwnerIDs;
+	std::vector<std::string> charComparisonKeys;
+	std::vector<int> charMemberless;
+	std::vector<std::string> charPasswords;
+	std::vector<int> charMailingLists;
+	std::vector<int> charCSPAs;
+	std::vector<int> charTemporaries;
+	std::vector<int> charModes;
+	int channelCount = 0;
+
+	// Get this character's subscribed Private Channel names and IDs:
+	m_db.GetChannelSubscriptions(call.client->GetCharacterID(), charChannelIDs, charChannelNames, charChannelMOTDs,
+		charOwnerIDs, charComparisonKeys, charMemberless, charPasswords, charMailingLists, charCSPAs, charTemporaries,
+		charModes, channelCount);
+	
+	LSCChannel * channel;
+	if( channelCount > 0 )
+	{
+		// Check each private chat channel listed in the names/IDs just procurred to
+		// see if they exist yet and if not, create them:
+		for( int i=0; i<channelCount; i++ )
+		{
+		    if( m_channels.find(charChannelIDs[i]) == m_channels.end() )
+			{
+				// Create each private chat channel listed in the names/IDs just procurred
+				// and grab a pointer to them while we're at it:
+				//channel = CreateChannel(charChannelIDs[i], charChannelNames[i].c_str(),
+				//	charChannelMOTDs[i].c_str(), LSCChannel::normal);
+				channel = CreateChannel(
+					charChannelIDs[i],
+					charChannelNames[i].c_str(),
+					charChannelMOTDs[i].c_str(),
+					LSCChannel::normal,
+					charComparisonKeys[i].c_str(),
+					charOwnerIDs[i],
+					(charMemberless[i] ? true : false),
+					charPasswords[i].c_str(),
+					(charMailingLists[i] ? true : false),
+					charCSPAs[i],
+					charTemporaries[i],
+					charModes[i]
+					);
+			}
+		}
+	}
+
     ChannelInfo info;
     info.lines = new PyList;
 
@@ -122,14 +272,17 @@
     for(; cur != end; cur++)
         info.lines->AddItem( cur->second->EncodeChannel( call.client->GetCharacterID() ) );
 
-    return info.Encode();
+	return info.Encode();
 }
 
+
 PyResult LSCService::Handle_GetRookieHelpChannel(PyCallArgs &call) {
     return(new PyInt(1));
 }
 
+
 PyResult LSCService::Handle_JoinChannels(PyCallArgs &call) {
+
     CallJoinChannels args;
     if (!args.Decode(&call.tuple)) {
         codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
@@ -171,6 +324,14 @@
         }
     }
 
+    // ********** TODO **********
+    // Figure out how to send the right packet to the client requesting the joining of this channel
+    // to query that client for a password to join this channel if indeed there is a password required.
+    // Check the password supplied by the client against the password stored in the LSCChannel object
+    // or queried from the database if this channel has not had its own LSCChannel object created and
+    // allow joining to this channel if passwords match.
+    // **************************
+ 
     uint32 charID = call.client->GetCharacterID();
     // and now ensure the working of the system
     toJoin.insert( charID );
@@ -180,37 +341,117 @@
     std::set<uint32>::iterator curs, ends;
     curs = toJoin.begin();
     ends = toJoin.end();
+
+	// Determine if the character is more than 30 days old (30*24*60*60*(1/0.0000001),
+    // and, if so, then set a flag that avoids joining this character to the Help\Help and
+    // Help\Rookie channels.
+	bool bSkipRookieChannelsForOlderChars = false;
+	if( ((Win32TimeNow() - (call.client->GetChar()->createDateTime())) > ((uint64)25920000000000)) )
+		bSkipRookieChannelsForOlderChars = true;
+
     for( ; curs != ends; curs++ )
 	{
 		LSCChannel *channel;
 
         uint32 channelID = *curs;
-        if( m_channels.find( channelID ) == m_channels.end() )
-            channel = CreateChannel( channelID );
-        else
-            channel = m_channels[ channelID ];
 
-        if( !channel->IsJoined( charID ) )
+		// Skip joining Help\Rookie and Help\Help channels when the character is older than 30 days:
+		if( (!(((channelID == 1) || (channelID == 2)) && bSkipRookieChannelsForOlderChars)) )
 		{
-            ChannelJoinReply chjr;
+			if( m_channels.find( channelID ) == m_channels.end() )
+				channel = CreateChannel( channelID );
+			else
+				channel = m_channels[ channelID ];
 
-            chjr.ChannelID = channel->EncodeID();
-            chjr.ChannelInfo = channel->EncodeChannelSmall( charID );
-            // this one'll create an empty query result
-            // noone implemented channel mods.
-            chjr.ChannelMods = channel->EncodeChannelMods();
-            chjr.ChannelChars = channel->EncodeChannelChars();
-           // chjr.ChannelChars = channel->EncodeEmptyChannelChars();
+			if( !channel->IsJoined( charID ) )
+			{
+				ChannelJoinReply chjr;
 
-            channel->JoinChannel( call.client );
+				chjr.ChannelID = channel->EncodeID();
+				chjr.ChannelInfo = channel->EncodeChannelSmall( charID );
+				// this one'll create an empty query result
+				// noone implemented channel mods.
+				chjr.ChannelMods = channel->EncodeChannelMods();
+				chjr.ChannelChars = channel->EncodeChannelChars();
+			   // chjr.ChannelChars = channel->EncodeEmptyChannelChars();
 
-            ml->AddItem( chjr.Encode() );
-        }
+				channel->JoinChannel( call.client );
+
+				// Save this subscription to this channel to the database
+				if (!(m_db.IsChannelSubscribedByThisChar(charID, channel->GetChannelID())))
+					m_db.WriteNewChannelSubscriptionToDatabase( charID, channel->GetChannelID() );
+
+				ml->AddItem( chjr.Encode() );
+			}
+		}
     }
 
     return ml;
 }
 
+
+PyResult LSCService::Handle_LeaveChannel(PyCallArgs &call) {
+    CallLeaveChannel arg;
+    if (!arg.Decode(&call.tuple)) {
+        codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
+        return NULL;
+    }
+
+    uint32 toLeave;
+
+    if( arg.channel->IsInt() )
+        toLeave = arg.channel->AsInt()->value();
+    else if( arg.channel->IsTuple() )
+    {
+        PyTuple* prt = arg.channel->AsTuple();
+
+        if( prt->GetItem( 0 )->IsInt() )
+            toLeave = prt->GetItem( 0 )->AsInt()->value();
+        else if( prt->GetItem( 0 )->IsTuple() )
+        {
+            prt = prt->GetItem( 0 )->AsTuple();
+
+            if( prt->items.size() != 2 || !prt->GetItem( 1 )->IsInt() )
+            {
+                codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
+                return NULL;
+            }
+
+            toLeave = prt->GetItem( 1 )->AsInt()->value();
+        }
+        else
+        {
+            codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
+            return NULL;
+        }
+    }
+    else
+    {
+        codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
+        return NULL;
+    }
+
+
+    if( m_channels.find( toLeave ) != m_channels.end() )
+    {
+        // Remove channel subscription from database if this character was subscribed to it.
+        // NOTE: channel subscriptions are NOT saved to the database for private convo chats
+        if (m_db.IsChannelSubscribedByThisChar(call.client->GetCharacterID(),toLeave))
+            m_db.RemoveChannelSubscriptionFromDatabase(toLeave,call.client->GetCharacterID());
+
+        // Remove channel from database if this character was the last one
+        // in the channel to leave and it was a private convo (temporary==1):
+        if ((m_channels.find( toLeave )->second->GetMemberCount() == 1)
+            && (m_channels.find( toLeave )->second->GetTemporary() != 0))
+                m_db.RemoveChannelFromDatabase(toLeave);
+
+        m_channels[ toLeave ]->LeaveChannel( call.client );
+    }
+
+    return NULL;
+}
+
+
 PyResult LSCService::Handle_LeaveChannels(PyCallArgs &call) {
     CallLeaveChannels args;
 
@@ -269,7 +510,19 @@
     {
         std::set<uint32>::iterator cur = toLeave.begin(), end = toLeave.end();
         for (;cur!=end;cur++) {
-            if (m_channels.find(*cur) != m_channels.end()) {
+            if (m_channels.find(*cur) != m_channels.end())
+            {
+                // Remove channel subscription from database if this character was subscribed to it.
+                // NOTE: channel subscriptions are NOT saved to the database for private convo chats
+                if (m_db.IsChannelSubscribedByThisChar(call.client->GetCharacterID(),*cur))
+                    m_db.RemoveChannelSubscriptionFromDatabase(*cur,call.client->GetCharacterID());
+
+                // Remove channel from database if this character was the last one
+                // in the channel to leave and it was a private convo (temporary==1):
+                if ((m_channels.find( *cur )->second->GetMemberCount() == 1)
+                    && (m_channels.find( *cur )->second->GetTemporary() != 0))
+                        m_db.RemoveChannelFromDatabase(*cur);
+
                 m_channels[*cur]->LeaveChannel(call.client);
             }
         }
@@ -277,6 +530,8 @@
 
     return (new PyNone());
 }
+
+
 void LSCService::CharacterLogout(uint32 charID, OnLSC_SenderInfo* si)
 {
     std::map<uint32, LSCChannel*>::iterator cur, end;
@@ -289,73 +544,357 @@
     SafeDelete( si );
 }
 
-PyResult LSCService::Handle_LeaveChannel(PyCallArgs &call) {
-    CallLeaveChannel arg;
-    if (!arg.Decode(&call.tuple)) {
-        codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
+
+PyResult LSCService::Handle_CreateChannel( PyCallArgs& call )
+{
+	// WARNING: This call contains manual packet decoding to handle configuring parameters for
+	// user-created chat channels since I didn't want to monkey around with the LSCPkts.xmlp.
+	// -- Aknor Jaden (2010-11-26)
+
+    Call_SingleWStringSoftArg name;
+	LSCChannel* channel = NULL;
+
+	if( !name.Decode( call.tuple ) )
+    {
+        sLog.Error( "LSCService", "%s: Invalid arguments", call.client->GetName() );
         return NULL;
     }
 
-    uint32 toLeave;
+	bool create_channel_exists = false;
+	bool create_channel = false;
+	bool temporary_exists = false;
+	bool temporary_channel = false;
+	bool joinExisting_exists = false;
+	bool joinExisting_channel = false;
 
-    if( arg.channel->IsInt() )
-        toLeave = arg.channel->AsInt()->value();
-    else if( arg.channel->IsTuple() )
-    {
-        PyTuple* prt = arg.channel->AsTuple();
+	if (call.byname.find("create") != call.byname.end())
+	{
+		create_channel_exists = true;
+		if (call.byname.find("create")->second->AsBool()->value())
+			create_channel = true;
+	}
 
-        if( prt->GetItem( 0 )->IsInt() )
-            toLeave = prt->GetItem( 0 )->AsInt()->value();
-        else if( prt->GetItem( 0 )->IsTuple() )
-        {
-            prt = prt->GetItem( 0 )->AsTuple();
+	if (call.byname.find("temporary") != call.byname.end())
+	{
+		temporary_exists = true;
+		if (call.byname.find("temporary")->second->AsBool()->value())
+			temporary_channel = true;
+	}
 
-            if( prt->items.size() != 2 || !prt->GetItem( 1 )->IsInt() )
-            {
-                codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
-                return NULL;
-            }
+	if (call.byname.find("joinExisting") != call.byname.end())
+	{
+		joinExisting_exists = true;
+		if (call.byname.find("joinExisting")->second->AsBool()->value())
+			joinExisting_channel = true;
+	}
 
-            toLeave = prt->GetItem( 1 )->AsInt()->value();
-        }
-        else
-        {
-            codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
-            return NULL;
-        }
-    }
-    else
-    {
-        codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
-        return NULL;
-    }
 
+	if (create_channel_exists && create_channel)
+	{
+		// Query Database to see if a channel with this name does not exist and, if so, create the channel,
+		// otherwise, set the channel pointer to NULL
+		if (m_db.IsChannelNameAvailable(name.arg))
+			channel = CreateChannel( name.arg.c_str() );
+		else
+		{
+			sLog.Error( "LSCService", "%s: Error creating new chat channel: channel name '%s' already exists.", call.client->GetName(), name.arg.c_str() );
+			channel = NULL;
+		}
 
-    if( m_channels.find( toLeave ) != m_channels.end() )
-        m_channels[ toLeave ]->LeaveChannel( call.client );
+		if (channel == NULL)
+		{
+			sLog.Error( "LSCService", "%s: Error creating new chat channel", call.client->GetName() );
+			return NULL;
+		}
 
-    return NULL;
+		// Save channel info and channel subscription to the database
+		m_db.WriteNewChannelToDatabase(channel->GetChannelID(),channel->GetDisplayName(),call.client->GetCharacterID(),0);
+		m_db.WriteNewChannelSubscriptionToDatabase(call.client->GetCharacterID(),channel->GetChannelID());
+
+		channel->JoinChannel( call.client );
+
+		ChannelCreateReply reply;
+		reply.ChannelChars = channel->EncodeChannelChars();
+		reply.ChannelInfo = channel->EncodeChannelSmall( call.client->GetCharacterID() );
+		reply.ChannelMods = channel->EncodeChannelMods();
+		return reply.Encode();
+	}
+
+
+	if (joinExisting_exists && joinExisting_channel)
+	{
+		std::string channel_name = call.tuple->items[0]->AsWString()->content();
+
+		if (!(m_db.IsChannelNameAvailable(channel_name)))
+		{
+			// Channel exists, so get its info from database and create this channel in the cache:
+			std::string ch_name, ch_motd, ch_compkey, ch_password;
+			uint32 ch_ID, ch_ownerID, ch_cspa, ch_temp, ch_mode;
+			bool ch_memberless, ch_maillist;
+			LSCChannel::Type ch_type = LSCChannel::normal;
+
+			m_db.GetChannelInformation(channel_name,ch_ID,ch_motd,ch_ownerID,ch_compkey,ch_memberless,ch_password,ch_maillist,ch_cspa,ch_temp,ch_mode);
+
+			channel = CreateChannel
+			(
+				ch_ID,
+				channel_name.c_str(),
+				ch_motd.c_str(),
+				ch_type,
+				ch_compkey.c_str(),
+				ch_ownerID,
+				ch_memberless,
+				ch_password.c_str(),
+				ch_maillist,
+				ch_cspa,
+				ch_temp,
+				ch_mode
+			);
+
+			if (channel == NULL)
+			{
+				sLog.Error( "LSCService", "%s: Error creating new chat channel", call.client->GetName() );
+				return NULL;
+			}
+		}
+		else
+		{
+			sLog.Error( "LSCService", "%s: Unable to join channel '%s', this channel does not exist.", call.client->GetName(), channel_name.c_str() );
+			return NULL;
+		}
+	}
+
+
+	if (temporary_exists && temporary_channel)
+	{
+		uint32 channel_id;
+		channel_id = m_db.GetNextAvailableChannelID();
+
+		// This is a temporary private chat channel, so don't look for it in the database, just make a new one:
+		channel = CreateChannel
+		(
+			channel_id,
+			call.tuple->GetItem(0)->AsString()->content().c_str(),
+			"",
+			LSCChannel::normal,
+			"",
+			call.client->GetCharacterID(),
+			false,
+			"",
+			false,
+			0,
+			1,
+			0
+		);
+
+		if (channel == NULL)
+		{
+			sLog.Error( "LSCService", "%s: Error creating new Temporary chat channel", call.client->GetName() );
+			return NULL;
+		}
+
+		// Save this channel to the database with the 'temporary' field marked as 1 so that when the last character
+		// leaves this channel, the server knows to remove it from the database:
+		m_db.WriteNewChannelToDatabase(channel_id,call.tuple->GetItem(0)->AsString()->content(),call.client->GetCharacterID(),1);
+	}
+
+
+	if ((joinExisting_exists && joinExisting_channel) || (temporary_exists && temporary_channel))
+	{
+		// Now that channel is created, join it:
+		if( !channel->IsJoined( call.client->GetCharacterID() ) )
+		{
+			// Save this subscription to this channel to the database IF it is not temporary:
+			if (channel->GetTemporary() == 0)
+				m_db.WriteNewChannelSubscriptionToDatabase( call.client->GetCharacterID(), channel->GetChannelID() );
+
+			channel->JoinChannel( call.client );
+
+			ChannelCreateReply reply;
+			reply.ChannelChars = channel->EncodeChannelChars();
+			reply.ChannelInfo = channel->EncodeChannelSmall( call.client->GetCharacterID() );
+			reply.ChannelMods = channel->EncodeChannelMods();
+			return reply.Encode();
+		}
+
+		// Somehow execution got here and was not captured in either Creating a new channel, Joining a temporary channel,
+		// or Joining an existing channel, so print an error:
+		sLog.Error( "LSCService", "%s: ERROR: Character %u tried to join/create channel '%s'.  The packet format was unexpected.", call.client->GetName(), call.client->GetCharacterID(), channel->GetDisplayName().c_str() );
+		return NULL;
+	}
+	else
+	{
+		// Malformed packet somehow / no "create" field in byname map
+		sLog.Error( "LSCService", "%s: Malformed packet: 'create' field in byname map is missing.", call.client->GetName() );
+		return NULL;
+	}
 }
 
-PyResult LSCService::Handle_CreateChannel( PyCallArgs& call )
+
+PyResult LSCService::Handle_Configure( PyCallArgs& call )
 {
-    Call_SingleWStringSoftArg name;
-    if( !name.Decode( call.tuple ) )
+	// WARNING: This call contains manual packet decoding to handle configuring parameters for
+	// user-created chat channels since I didn't want to monkey around with the LSCPkts.xmlp.
+	// -- Aknor Jaden (2010-11-26)
+
+	LSCChannel* channel = NULL;
+	int32 channel_id = 0;
+
+	//ChannelInfo args;
+    //if (!args.Decode( call.tuple )) {
+    //    codelog(SERVICE__ERROR, "%s: Bad arguments", call.client->GetName());
+    //    return NULL;
+    //}
+
+	// Get Tuple which contains channel number to modify:
+	if (call.tuple->AsTuple()->GetItem(0)->IsInt())
+		channel_id = call.tuple->AsTuple()->GetItem(0)->AsInt()->value();
+	else
+	{
+        sLog.Error( "LSCService", "%s: Tuple contained wrong type: '%s'", call.client->GetName(), call.tuple->TypeString() );
+        return NULL;
+	}
+
+	// Get count of parameters or just loop through the std::map until you've reached the end
+	if (call.byname.size() == 0)
+	{
+        sLog.Error( "LSCService", "%s: byname std::map contained zero elements, expected at least one.", call.client->GetName() );
+        return NULL;
+	}
+
+	// Find channel in existing channels:
+    std::map<uint32, LSCChannel*>::iterator res = m_channels.find( channel_id );
+    if( m_channels.end() == res )
     {
-        sLog.Error( "LSCService", "%s: Invalid arguments", call.client->GetName() );
+        sLog.Error( "LSCService", "%s: Handle_Configure Couldn't find channel %u", call.client->GetName(), channel_id );
         return NULL;
     }
 
-    LSCChannel* channel = CreateChannel( name.arg.c_str() );
-    channel->JoinChannel( call.client );
+    channel = m_channels.find(channel_id)->second;
 
+	std::string str_NEW_displayName;
+	int32 int_NEW_memberless;
+	std::string str_NEW_motd;
+	std::string str_newPassword;
+	std::string str_oldPassword;
+
+	// For each entry in the map, check its first value against one of these strings, then call appropriate set() function:
+	//		"displayName"
+	if (!(call.byname.find("displayName") == call.byname.end()))
+	{
+		if (call.byname.find("displayName")->second->IsWString())
+		{
+			str_NEW_displayName = call.byname.find("displayName")->second->AsWString()->content();
+			channel->SetDisplayName(str_NEW_displayName);
+		}
+		else
+		{
+			sLog.Error( "LSCService", "%s: displayName contained wrong type: '%s'", call.client->GetName(), call.byname.find("displayName")->second->TypeString() );
+			return NULL;
+		}
+	}
+
+	//		"memberless"
+	if (!(call.byname.find("memberless") == call.byname.end()))
+	{
+		if (call.byname.find("memberless")->second->IsInt())
+		{
+			int_NEW_memberless = call.byname.find("memberless")->second->AsInt()->value();
+			channel->SetMemberless(int_NEW_memberless ? true : false);
+		}
+		else
+		{
+			sLog.Error( "LSCService", "%s: memberless contained wrong type: '%s'", call.client->GetName(), call.byname.find("memberless")->second->TypeString() );
+			return NULL;
+		}
+	}
+
+	//		"motd"
+	if (!(call.byname.find("motd") == call.byname.end()))
+	{
+		if (call.byname.find("motd")->second->IsWString())
+		{
+			str_NEW_motd = call.byname.find("motd")->second->AsWString()->content();
+			channel->SetMOTD(str_NEW_motd);
+		}
+		else
+		{
+			sLog.Error( "LSCService", "%s: motd contained wrong type: '%s'", call.client->GetName(), call.byname.find("motd")->second->TypeString() );
+			return NULL;
+		}
+	}
+
+	//		"oldPassword"
+	if (!(call.byname.find("oldPassword") == call.byname.end()))
+	{
+		if (call.byname.find("oldPassword")->second->IsWString())
+		{
+			str_oldPassword = call.byname.find("oldPassword")->second->AsWString()->content();
+			if (channel->GetPassword() == str_oldPassword)
+			{
+				//		"newPassword"
+				if (!(call.byname.find("newPassword") == call.byname.end()))
+				{
+					if (call.byname.find("newPassword")->second->IsWString())
+					{
+						str_newPassword = call.byname.find("newPassword")->second->AsWString()->content();
+						channel->SetPassword(str_newPassword);
+					}
+					else
+					{
+						sLog.Error( "LSCService", "%s: newPassword contained wrong type: '%s'", call.client->GetName(), call.byname.find("newPassword")->second->TypeString() );
+						return NULL;
+					}
+				}
+			}
+			else
+			{
+				sLog.Error( "LSCService", "%s: incorrect oldPassword supplied. Password NOT changed.", call.client->GetName() );
+				return NULL;
+			}
+		}
+		else if (call.byname.find("oldPassword")->second->IsNone())
+		{
+			//		"newPassword"
+			if (!(call.byname.find("newPassword") == call.byname.end()))
+			{
+				if (call.byname.find("newPassword")->second->IsWString())
+				{
+					str_newPassword = call.byname.find("newPassword")->second->AsWString()->content();
+					channel->SetPassword(str_newPassword);
+				}
+				else
+				{
+					sLog.Error( "LSCService", "%s: newPassword contained wrong type: '%s'", call.client->GetName(), call.byname.find("newPassword")->second->TypeString() );
+					return NULL;
+				}
+			}
+		}
+		else
+		{
+			sLog.Error( "LSCService", "%s: oldPassword is of an unexpected type: '%s'", call.client->GetName(), call.byname.find("newPassword")->second->TypeString() );
+			return NULL;
+		}
+	}
+
+	// Save the new channel parameters to the database 'channels' table:
+    m_db.UpdateChannelConfigureInfo(channel);
+
+    // ********** TODO **********
+    // Figure out how to send a packet to all clients subscribed to this channel that contains all channel parameters
+    // so that their clients can update everything that has changed in this channel's configuration.
+    // **************************
+
+    // This packet sent back to the client configuring the channel parameters is insufficient to update itself or
+    // any other client attached to this channel.
     ChannelCreateReply reply;
-	reply.ChannelChars = channel->EncodeChannelChars();
+    reply.ChannelChars = channel->EncodeChannelChars();
     reply.ChannelInfo = channel->EncodeChannelSmall( call.client->GetCharacterID() );
     reply.ChannelMods = channel->EncodeChannelMods();
     return reply.Encode();
 }
 
+
 PyResult LSCService::Handle_DestroyChannel( PyCallArgs& call )
 {
     Call_SingleIntegerArg arg;
@@ -372,98 +911,224 @@
         return NULL;
     }
 
+    // ********** TODO **********
+    // Figure out how to validate whether this character (call.client->GetCharacterID()) is allowed
+    // to destroy this chat channel, and proceed if they are, otherwise, do not.  And, is there an error
+    // packet sent back to the client?
+    // **************************
+
     res->second->Evacuate( call.client );
     SafeDelete( res->second );
     m_channels.erase( res );
 
+    // Now, remove the channel from the database:
+    m_db.RemoveChannelFromDatabase( res->second->GetChannelID() );
+
     return new PyNone;
 }
 
+
 PyResult LSCService::Handle_SendMessage( PyCallArgs& call )
 {
+	// WARNING: This call contains manual packet decoding to handle chat messages sent inside user-created
+	// chat channels since I didn't want to monkey around with the LSCPkts.xmlp.  All chat message packets
+	// received for Local/Corp/Region/Constellation chat channels are still processed via LSCPkts.cpp.
+	// -- Aknor Jaden (2010-11-07)
+
+	int32 channel_id = 0;
+	std::string message;
+
     Call_SendMessage args;
-    if( !args.Decode( call.tuple ) )
+
+	if( ( call.tuple->IsTuple() ) && (call.tuple->AsTuple()->items[0]->IsInt()) )
     {
-        sLog.Error( "LSCService", "%s: Invalid arguments", call.client->GetName() );
-        return NULL;
+		// Decode All User-created chat channel messages here:
+		if( !call.tuple->IsTuple() )
+		{
+			_log( NET__PACKET_ERROR, "LSCService::Handle_SendMessage failed: tuple0 is the wrong type: %s", call.tuple->TypeString() );
+
+			return false;
+		}
+		PyTuple* tuple0 = call.tuple->AsTuple();
+
+		if( tuple0->size() != 2 )
+		{
+			_log( NET__PACKET_ERROR, "LSCService::Handle_SendMessage failed: tuple0 is the wrong size: expected 2, but got %lu", tuple0->size() );
+
+			return false;
+		}
+
+		channel_id = (call.tuple->AsTuple()->items[0]->AsInt())->value();
+		message = ((call.tuple->AsTuple()->items[1]->AsWString())->content());
+		sLog.Log( "LSCService", "Handle_SwndMessage: call is either User-created chat message or bad packet.");
     }
+	else
+	{
+		// Decode All system (local, corp, region, etc) chat channel messages here:
+		if( !args.Decode( call.tuple ) )
+		{
+			sLog.Error( "LSCService", "%s: Invalid arguments", call.client->GetName() );
+			return NULL;
+		}
+		channel_id = args.channel.id;
+		message = args.message;
+		sLog.Log( "LSCService", "Handle_SwndMessage: call is Corp/Local/Region/Constellation chat.");
+	}
 
-    std::map<uint32, LSCChannel*>::iterator res = m_channels.find( args.channel.id );
+    std::map<uint32, LSCChannel*>::iterator res = m_channels.find( channel_id );
     if( m_channels.end() == res )
     {
-        sLog.Error( "LSCService", "%s: Couldn't find channel %u", call.client->GetName(), args.channel.id );
+        sLog.Error( "LSCService", "%s: Couldn't find channel %u", call.client->GetName(), channel_id );
         return NULL;
     }
 
-    res->second->SendMessage( call.client, args.message.c_str() );
+	res->second->SendMessage( call.client, message.c_str() );
     return new PyInt( 1 );
 }
 
 
+PyResult LSCService::Handle_AccessControl( PyCallArgs& call )
+{
+	// WARNING: This call contains manual packet decoding to handle Access Control since I didn't want to monkey around with the LSCPkts.xmlp.
+	// -- Aknor Jaden (2010-11-26)
 
+	int32 channel_id = 0;
 
+    // call.tuple->GetItem(0)->AsInt()->value() = channel ID
+    // call.tuple->GetItem(1)->IsNone() == true  <---- change made to "" field
+    // call.tuple->GetItem(2)->AsInt()->value() =
+    //     0 = ??
+    //     1 = Moderated
+    //     2 = ??
+    //     3 = Allowed
 
+    // call.tuple->GetItem(1)->IsInt() == true  <---- character ID for character add to one of the lists specified by GetItem(2):
+    // call.tuple->GetItem(2)->AsInt()->value() =
+    //     3 = Add to Allowed List
+    //     -2 = Add to Blocked List
+    //     7 = Add to Moderators List
 
 
- 
+    // ********** TODO **********
+    // Figure out how to send a packet to all clients subscribed to this channel that contains all channel parameters
+    // so that their clients can update everything that has changed in this channel's access control.
+    // **************************
 
-const int cmode = 2950;
-
-LSCChannel *LSCService::CreateChannel(uint32 channelID, const char * name, const char * motd, LSCChannel::Type type, bool maillist) {
-	return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name, motd, NULL, false, "", maillist, true, false, cmode);//ownerID must be sent in responce to GetEveOwners
+    return new PyInt( 1 );
 }
-LSCChannel *LSCService::CreateChannel(uint32 channelID, const char * name, LSCChannel::Type type, bool maillist) {
- 	return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name, NULL, NULL, false, "", maillist, true, false, cmode);
-}
-LSCChannel *LSCService::CreateChannel(uint32 channelID) {
-    LSCChannel::Type type;
-    std::string name;
-    std::string motd;
-    if (IsRegion(channelID)) { type = LSCChannel::region; name = "System Channels\\Region"; motd = m_db.GetRegionName(channelID); }
-    else if (IsConstellation(channelID)) {type = LSCChannel::constellation; name = "System Channels\\Constellation"; motd = m_db.GetConstellationName(channelID); }
-    else if (IsSolarSystem(channelID)) { type = LSCChannel::solarsystem; name = "System Channels\\Local"; motd = m_db.GetSolarSystemName(channelID); }
-    // official corporations
-    else if ((channelID >= 1000000) && (channelID < 2000000)) { type = LSCChannel::corp; name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
-    // player-created corporations
-    else if ((channelID >= 2000000) && (channelID < 3000000)) { type = LSCChannel::corp; name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
-    else { type = LSCChannel::normal; name = m_db.GetCharacterName(channelID); motd = ""; } // this is either a char channel or something i have no idea about
 
-	return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name.c_str(), motd.c_str(), NULL, false, NULL, false, true, false, cmode);
-}
-LSCChannel *LSCService::CreateChannel(uint32 channelID, LSCChannel::Type type) {
-    std::string name;
-    std::string motd;
-    if (IsRegion(channelID)) { name = "System Channels\\Region"; motd = m_db.GetRegionName(channelID); }
-    else if (IsConstellation(channelID)) { name = "System Channels\\Constellation"; motd = m_db.GetConstellationName(channelID); }
-    else if (IsSolarSystem(channelID)) { name = "System Channels\\Local"; motd = m_db.GetSolarSystemName(channelID); }
-    // official corporations
-    else if ((channelID >= 1000000) && (channelID < 2000000)) { name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
-    // player-created corporations
-    else if ((channelID >= 2000000) && (channelID < 3000000)) { name = "System Channels\\Corp"; motd = m_db.GetCorporationName(channelID); }
-    // this is either a char channel or something i have no idea about
-    else { name = m_db.GetCharacterName(channelID); motd = ""; }
+PyResult LSCService::Handle_Invite(PyCallArgs &call)
+{
+	// WARNING: This call contains manual packet decoding to handle chat messages sent inside user-created
+	// chat channels since I didn't want to monkey around with the LSCPkts.xmlp.
+	// -- Aknor Jaden (2010-11-19)
 
-    return m_channels[channelID] = new LSCChannel(this, channelID, type, 1, name.c_str(), motd.c_str(), NULL, false, NULL, false, true, false, cmode);
+	LSCChannel *channel;
+
+	uint32 channel_ID;
+	uint32 char_ID = call.client->GetCharacterID();
+	uint32 invited_char_ID;
+
+	// Decode the call:
+	if (call.tuple->IsTuple())
+	{
+		if (call.tuple->GetItem(1)->IsInt())
+			channel_ID = call.tuple->GetItem(1)->AsInt()->value();
+		else
+		{
+			sLog.Error( "LSCService", "%s: call.tuple->GetItem(1) is of the wrong type: '%s'.  Expected PyInt type.", call.client->GetName(), call.tuple->TypeString() );
+			return NULL;
+		}
+
+		if (call.tuple->GetItem(0)->IsInt())
+			invited_char_ID = call.tuple->GetItem(0)->AsInt()->value();
+		else
+		{
+			sLog.Error( "LSCService", "%s: call.tuple->GetItem(0) is of the wrong type: '%s'.  Expected PyInt type.", call.client->GetName(), call.tuple->TypeString() );
+			return NULL;
+		}
+	}
+	else
+	{
+		sLog.Error( "LSCService", "%s: call.tuple is of the wrong type: '%s'.  Expected PyTuple type.", call.client->GetName(), call.tuple->TypeString() );
+		return NULL;
+	}
+
+	// Now that the packet is known to be good, find the channel to join and join it:
+	if (m_channels.find(channel_ID) != m_channels.end())
+	{
+		channel = m_channels[ channel_ID ];
+
+		if( !channel->IsJoined( invited_char_ID ) )
+		{
+			// SOMEHOW SEND A JOIN COMMAND/REQUEST TO THE TARGET CLIENT FOR invited_char_ID
+		/*	OnLSC_JoinChannel join;
+			join.sender = channel->_MakeSenderInfo(call.client);
+			join.member_count = 1;
+			join.channelID = channel->EncodeID();
+			PyTuple *answer = join.Encode();
+			MulticastTarget mct;
+			//LSCChannelChar *invitor;
+			//LSCChannelChar *invitee;
+			if ( !channel->IsJoined(char_ID) )
+			{
+				//invitor = new LSCChannelChar(channel,0,char_ID,call.client->GetCharacterName(),0,0,0,0);
+				mct.characters.insert(char_ID);
+			}
+			//invitee = new LSCChannelChar(channel,0,invited_char_ID,entityList().FindCharacter(invited_char_ID)->GetCharacterName(),0,0,0,0);
+			mct.characters.insert(invited_char_ID);
+			entityList().Multicast( "OnLSC", channel->GetTypeString(), &answer, mct );
+			//entityList().Unicast(invited_char_ID,"OnLSC",channel->GetTypeString(),&answer,false);
+        */
+
+            // ********** TODO **********
+            // Figure out how to send the ChatInvite packet to the client running the character with id = 'invited_char_ID'
+            // in order for that character's client to then issue the JoinChannels call to the server with the chat channel
+            // ID equal to that of this channel, be it either a private convo (temporary==1) or an existing user-created chat.
+            // **************************
+
+            //ChatInvite chatInvitePacket;
+            //chatInvitePacket.integer1 = 1;
+            //chatInvitePacket.integer2 = invited_char_ID;
+            //chatInvitePacket.boolean = true;
+            //chatInvitePacket.displayName = call.tuple->GetItem(2)->AsString()->content();
+            //chatInvitePacket.integer3 = 1;
+            //chatInvitePacket.integer4 = 0;
+            //chatInvitePacket.integer5 = 1;
+            //PyTuple *tuple = chatInvitePacket.Encode();
+            //entityList().Unicast(invited_char_ID, "", "", &tuple, false);
+
+			// Save this subscription to this channel to the database IF it is not temporary:
+			if ((channel->GetTemporary() == 0) && (m_db.IsChannelSubscribedByThisChar(invited_char_ID, channel_ID) == false))
+				m_db.WriteNewChannelSubscriptionToDatabase( invited_char_ID, channel_ID );
+		}
+		else
+		{
+			sLog.Error( "LSCService", "%s: Character %u is already joined to channel %u.", call.client->GetName(), invited_char_ID, channel_ID );
+			return NULL;
+		}
+	}
+	else
+	{
+		sLog.Error( "LSCService", "%s: Cannot find channel %u.", call.client->GetName(), channel_ID );
+		return NULL;
+	}
+
+	return new PyInt( 1 );
 }
-LSCChannel *LSCService::CreateChannel(const char * name, bool maillist) {
-    return CreateChannel(nextFreeChannelID++, name, LSCChannel::normal, maillist);
-}
-void LSCService::CreateSystemChannel(uint32 systemID) {
-    if (m_channels.find(systemID) == m_channels.end()) {
-        CreateChannel(systemID, "System Channels\\Local", m_db.GetSolarSystemName(systemID).c_str(), LSCChannel::solarsystem);
-    }
-}
-void LSCService::InitiateStaticChannels() {
-    // maybe, but only maybe, this stuff could be replaced by a nice database call
-    CreateChannel(1, "Help\\Rookie Help", "Rookie motd", LSCChannel::normal);
-    CreateChannel(2, "Help\\Help", "Help motd", LSCChannel::normal);
-}
 
 
+///////////////////////////////////////////////////////////////////////////////
+//
+// EveMail calls:
+//
+///////////////////////////////////////////////////////////////////////////////
+
 PyResult LSCService::Handle_GetMyMessages(PyCallArgs &call) {
     return(m_db.GetMailHeaders(call.client->GetCharacterID()));
 }
 
+
 PyResult LSCService::Handle_GetMessageDetails(PyCallArgs &call) {
     Call_TwoIntegerArgs args;
     if(!args.Decode(&call.tuple)) {
@@ -476,6 +1141,7 @@
     return(m_db.GetMailDetails(args.arg2, args.arg1));
 }
 
+
 PyResult LSCService::Handle_Page(PyCallArgs &call) {
     Call_Page args;
     if(!args.Decode(&call.tuple)) {
@@ -490,6 +1156,7 @@
     return NULL;
 }
 
+
 //stuck here to be close to related functionality
 void LSCService::SendMail(uint32 sender, const std::vector<int32> &recipients, const std::string &subject, const std::string &content) {
     NotifyOnMessage notify;
@@ -527,6 +1194,7 @@
     m_manager->entity_list.Multicast(successful_recipients, "OnMessage", "*multicastID", &answer, false);
 }
 
+
 //stuck here to be close to related functionality
 //theres a lot of duplicated crap in here...
 //this could be replaced by the SendNewEveMail if it weren't in the Client
@@ -545,6 +1213,7 @@
     SafeFree( str );
 }
 
+
 PyResult LSCService::Handle_MarkMessagesRead(PyCallArgs &call) {
     Call_SingleIntList args;
     if(!args.Decode(&call.tuple)) {
@@ -561,6 +1230,7 @@
     return NULL;
 }
 
+
 PyResult LSCService::Handle_DeleteMessages(PyCallArgs &call) {
     Call_DeleteMessages args;
     if(!args.Decode(&call.tuple)) {
@@ -583,6 +1253,7 @@
     return NULL;
 }
 
+
 PyResult LSCService::Handle_GetMembers(PyCallArgs &call) {
 	CallGetMembers arg;
 	if (!arg.Decode(&call.tuple)) {
@@ -629,32 +1300,12 @@
 	return NULL;
 }
 
+
 PyResult LSCService::Handle_GetMember(PyCallArgs &call) {
 	return NULL;
 }
 
+
 PyResult LSCService::ExecuteCommand(Client *from, const char *msg) {
     return(m_commandDispatch->Execute(from, msg));
 }
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
